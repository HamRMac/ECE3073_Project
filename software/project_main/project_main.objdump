
project_main.elf:     file format elf32-littlenios2
project_main.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x04040188

Program Header:
    LOAD off    0x00001000 vaddr 0x04040000 paddr 0x04040000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x04040020 paddr 0x04040020 align 2**12
         filesz 0x0000097c memsz 0x0000097c flags r-x
    LOAD off    0x00002000 vaddr 0x02000000 paddr 0x0404099c align 2**12
         filesz 0x00000078 memsz 0x00000194 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  04040000  04040000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000168  04040020  04040020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00000814  04040188  04040188  00001188  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       0000006c  02000000  0404099c  00002000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       0000000c  0200006c  04040a08  0000206c  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0000011c  02000078  04040a14  00002078  2**2
                  ALLOC, SMALL_DATA
  6 .SDRAM        00000000  02000194  02000194  00002078  2**0
                  CONTENTS
  7 .NIOS_MEM     00000000  04040a14  04040a14  00002078  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  00002078  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 000002d8  00000000  00000000  000020a0  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   00001c9b  00000000  00000000  00002378  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00000fa7  00000000  00000000  00004013  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00000f16  00000000  00000000  00004fba  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00000384  00000000  00000000  00005ed0  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00000d61  00000000  00000000  00006254  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0000096b  00000000  00000000  00006fb5  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000030  00000000  00000000  00007920  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00000170  00000000  00000000  00007950  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000003  00000000  00000000  00008c82  2**0
                  CONTENTS, READONLY
 19 .cpu          00000009  00000000  00000000  00008c85  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  00008c8e  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  00008c8f  2**0
                  CONTENTS, READONLY
 22 .stderr_dev   00000009  00000000  00000000  00008c90  2**0
                  CONTENTS, READONLY
 23 .stdin_dev    00000009  00000000  00000000  00008c99  2**0
                  CONTENTS, READONLY
 24 .stdout_dev   00000009  00000000  00000000  00008ca2  2**0
                  CONTENTS, READONLY
 25 .sopc_system_name 00000010  00000000  00000000  00008cab  2**0
                  CONTENTS, READONLY
 26 .quartus_project_dir 00000028  00000000  00000000  00008cbb  2**0
                  CONTENTS, READONLY
 27 .jdi          00005673  00000000  00000000  00008ce3  2**0
                  CONTENTS, READONLY
 28 .sopcinfo     000612be  00000000  00000000  0000e356  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
04040000 l    d  .entry	00000000 .entry
04040020 l    d  .exceptions	00000000 .exceptions
04040188 l    d  .text	00000000 .text
02000000 l    d  .rodata	00000000 .rodata
0200006c l    d  .rwdata	00000000 .rwdata
02000078 l    d  .bss	00000000 .bss
02000194 l    d  .SDRAM	00000000 .SDRAM
04040a14 l    d  .NIOS_MEM	00000000 .NIOS_MEM
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../project_main_bsp//obj/HAL/src/crt0.o
040401d0 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 alt_putstr.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 strlen.c
02000090 g     O .bss	00000004 alt_instruction_exception_handler
04040634 g     F .text	0000002c alt_main
02000094 g     O .bss	00000100 alt_irq
04040a08 g       *ABS*	00000000 __flash_rwdata_start
04040818 g     F .text	00000038 alt_putstr
04040940 g     F .text	00000008 altera_nios2_gen2_irq_init
04040000 g     F .entry	0000001c __reset
0200007c g     O .bss	00000004 edge_capture
04040020 g       *ABS*	00000000 __flash_exceptions_start
02000088 g     O .bss	00000004 alt_argv
0200806c g       *ABS*	00000000 _gp
040401d4 g     F .text	00000040 clrBuffer
040408cc g     F .text	00000074 alt_exception_cause_generated_bad_addr
04040948 g     F .text	00000038 alt_icache_flush
02000194 g       *ABS*	00000000 __bss_end
040404ec g     F .text	00000068 alt_iic_isr_register
040404d4 g     F .text	00000018 alt_ic_irq_enabled
02000080 g     O .bss	00000004 alt_irq_active
040400fc g     F .exceptions	00000060 alt_irq_handler
040408a8 g     F .text	00000018 alt_dcache_flush_all
02000078 g       *ABS*	00000000 __ram_rwdata_end
0200006c g       *ABS*	00000000 __ram_rodata_end
00000000 g       *ABS*	00000000 __alt_mem_SDRAM
02000194 g       *ABS*	00000000 end
0404015c g     F .exceptions	0000002c alt_instruction_exception_entry
04000000 g       *ABS*	00000000 __alt_stack_pointer
04040874 g     F .text	00000034 altera_avalon_jtag_uart_write
04040660 g     F .text	00000170 alt_printf
04040188 g     F .text	0000004c _start
04040870 g     F .text	00000004 alt_sys_init
0200006c g       *ABS*	00000000 __ram_rwdata_start
02000000 g       *ABS*	00000000 __ram_rodata_start
02000194 g       *ABS*	00000000 __alt_stack_base
040403a0 g     F .text	0000005c KEY_IN_ISR
02000078 g       *ABS*	00000000 __bss_start
040403fc g     F .text	00000064 main
02000084 g     O .bss	00000004 alt_envp
04040214 g     F .text	0000018c writeImage
0404099c g       *ABS*	00000000 __flash_rodata_start
04040850 g     F .text	00000020 alt_irq_init
0200008c g     O .bss	00000004 alt_argc
04040020 g       .exceptions	00000000 alt_irq_entry
04040020 g       *ABS*	00000000 __ram_exceptions_start
04040460 g     F .text	00000004 alt_ic_isr_register
02000078 g       *ABS*	00000000 _edata
02000194 g       *ABS*	00000000 _end
04040188 g       *ABS*	00000000 __ram_exceptions_end
02000078 g     O .bss	00000001 flipImgFlags
0404049c g     F .text	00000038 alt_ic_irq_disable
04000000 g       *ABS*	00000000 __alt_data_end
04040020 g     F .exceptions	00000000 alt_exception
0404001c g       .entry	00000000 _exit
04040980 g     F .text	0000001c strlen
040407d0 g     F .text	00000048 alt_putchar
040408c0 g     F .text	0000000c alt_icache_flush_all
02000070 g     O .rwdata	00000004 alt_priority_mask
04040464 g     F .text	00000038 alt_ic_irq_enable
02000074 g     O .rwdata	00000004 UART_JTAG
0200006c g     O .rwdata	00000004 key_in_base
04040554 g     F .text	000000e0 alt_load
04040000 g       *ABS*	00000000 __alt_mem_NIOS_MEM



Disassembly of section .entry:

04040000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && (!defined(ALT_SIM_OPTIMIZE) || defined(NIOS2_ECC_PRESENT))
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
 4040000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
 4040004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
 4040008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
 404000c:	00bffd16 	blt	zero,r2,4040004 <__flash_rwdata_start+0xfffff5fc>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 4040010:	00410134 	movhi	at,1028
    ori r1, r1, %lo(_start)
 4040014:	08406214 	ori	at,at,392
    jmp r1
 4040018:	0800683a 	jmp	at

0404001c <_exit>:
 404001c:	00000000 	call	0 <__alt_mem_SDRAM>

Disassembly of section .exceptions:

04040020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
 4040020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
 4040024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
 4040028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 404002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 4040030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 4040034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 4040038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 404003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 4040040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
 4040044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
 4040048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 404004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 4040050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 4040054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 4040058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 404005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 4040060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 4040064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 4040068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 404006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 4040070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 4040074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 4040078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 404007c:	10000326 	beq	r2,zero,404008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
 4040080:	20000226 	beq	r4,zero,404008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 4040084:	40400fc0 	call	40400fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 4040088:	00000706 	br	40400a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
 404008c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
 4040090:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
 4040094:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
 4040098:	404015c0 	call	404015c <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
 404009c:	1000021e 	bne	r2,zero,40400a8 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
 40400a0:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 40400a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 40400a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 40400ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 40400b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 40400b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 40400b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 40400bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 40400c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 40400c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 40400c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 40400cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 40400d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
 40400d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 40400d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 40400dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 40400e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 40400e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 40400e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 40400ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 40400f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
 40400f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 40400f8:	ef80083a 	eret

040400fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 40400fc:	defffe04 	addi	sp,sp,-8
 4040100:	dfc00115 	stw	ra,4(sp)
 4040104:	dc000015 	stw	r16,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 4040108:	0009313a 	rdctl	r4,ipending
    do
    {
      if (active & mask)
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 404010c:	04008034 	movhi	r16,512
 4040110:	84002504 	addi	r16,r16,148

  active = alt_irq_pending ();

  do
  {
    i = 0;
 4040114:	0005883a 	mov	r2,zero
    mask = 1;
 4040118:	00c00044 	movi	r3,1
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 404011c:	20ca703a 	and	r5,r4,r3
 4040120:	28000b26 	beq	r5,zero,4040150 <alt_irq_handler+0x54>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 4040124:	100490fa 	slli	r2,r2,3
 4040128:	8085883a 	add	r2,r16,r2
 404012c:	10c00017 	ldw	r3,0(r2)
 4040130:	11000117 	ldw	r4,4(r2)
 4040134:	183ee83a 	callr	r3
 4040138:	0009313a 	rdctl	r4,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
 404013c:	203ff51e 	bne	r4,zero,4040114 <__flash_rwdata_start+0xfffff70c>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
 4040140:	dfc00117 	ldw	ra,4(sp)
 4040144:	dc000017 	ldw	r16,0(sp)
 4040148:	dec00204 	addi	sp,sp,8
 404014c:	f800283a 	ret
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
 4040150:	18c7883a 	add	r3,r3,r3
      i++;
 4040154:	10800044 	addi	r2,r2,1

    } while (1);
 4040158:	003ff006 	br	404011c <__flash_rwdata_start+0xfffff714>

0404015c <alt_instruction_exception_entry>:
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
 404015c:	000531fa 	rdctl	r2,exception
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
 4040160:	000d333a 	rdctl	r6,badaddr
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
 4040164:	d0e00917 	ldw	r3,-32732(gp)
 4040168:	18000426 	beq	r3,zero,404017c <alt_instruction_exception_entry+0x20>
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
 404016c:	10801f0c 	andi	r2,r2,124
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
 4040170:	200b883a 	mov	r5,r4
 4040174:	1008d0ba 	srli	r4,r2,2
 4040178:	1800683a 	jmp	r3
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
 404017c:	003da03a 	break	0
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
}
 4040180:	0005883a 	mov	r2,zero
 4040184:	f800283a 	ret

Disassembly of section .text:

04040188 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
 4040188:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
 404018c:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
 4040190:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
 4040194:	00bffd16 	blt	zero,r2,404018c <__flash_rwdata_start+0xfffff784>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 4040198:	06c10034 	movhi	sp,1024
    ori sp, sp, %lo(__alt_stack_pointer)
 404019c:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 40401a0:	06808034 	movhi	gp,512
    ori gp, gp, %lo(_gp)
 40401a4:	d6a01b14 	ori	gp,gp,32876
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 40401a8:	00808034 	movhi	r2,512
    ori r2, r2, %lo(__bss_start)
 40401ac:	10801e14 	ori	r2,r2,120

    movhi r3, %hi(__bss_end)
 40401b0:	00c08034 	movhi	r3,512
    ori r3, r3, %lo(__bss_end)
 40401b4:	18c06514 	ori	r3,r3,404

    beq r2, r3, 1f
 40401b8:	10c00326 	beq	r2,r3,40401c8 <_start+0x40>

0:
    stw zero, (r2)
 40401bc:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 40401c0:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 40401c4:	10fffd36 	bltu	r2,r3,40401bc <__flash_rwdata_start+0xfffff7b4>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 40401c8:	40405540 	call	4040554 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 40401cc:	40406340 	call	4040634 <alt_main>

040401d0 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 40401d0:	003fff06 	br	40401d0 <__flash_rwdata_start+0xfffff7c8>

040401d4 <clrBuffer>:
 *  when processor restarts/program initialises
 */
void clrBuffer() {
	for (int i = 0; i < BUF_MAX_PIX; i++) {
		  // Set Buffer Address
		  IOWR_32DIRECT(PB_ADR_BASE,0,i);
 40401d4:	01c10234 	movhi	r7,1032
		  // Enable Writing
		  IOWR_32DIRECT(PBUFF_WREN_BASE,0,1);
 40401d8:	00c10234 	movhi	r3,1032
		  // Write Data
		  IOWR_32DIRECT(PB_DATA_BASE,0,0);
 40401dc:	01410234 	movhi	r5,1032
 *  clrBuffer()
 *  Clears the pixel buffer. Used to clear screen
 *  when processor restarts/program initialises
 */
void clrBuffer() {
	for (int i = 0; i < BUF_MAX_PIX; i++) {
 40401e0:	0005883a 	mov	r2,zero
		  // Set Buffer Address
		  IOWR_32DIRECT(PB_ADR_BASE,0,i);
 40401e4:	39c41004 	addi	r7,r7,4160
		  // Enable Writing
		  IOWR_32DIRECT(PBUFF_WREN_BASE,0,1);
 40401e8:	01800044 	movi	r6,1
 40401ec:	18c40804 	addi	r3,r3,4128
		  // Write Data
		  IOWR_32DIRECT(PB_DATA_BASE,0,0);
 40401f0:	29440c04 	addi	r5,r5,4144
 *  clrBuffer()
 *  Clears the pixel buffer. Used to clear screen
 *  when processor restarts/program initialises
 */
void clrBuffer() {
	for (int i = 0; i < BUF_MAX_PIX; i++) {
 40401f4:	0112c004 	movi	r4,19200
		  // Set Buffer Address
		  IOWR_32DIRECT(PB_ADR_BASE,0,i);
 40401f8:	38800035 	stwio	r2,0(r7)
		  // Enable Writing
		  IOWR_32DIRECT(PBUFF_WREN_BASE,0,1);
 40401fc:	19800035 	stwio	r6,0(r3)
		  // Write Data
		  IOWR_32DIRECT(PB_DATA_BASE,0,0);
 4040200:	28000035 	stwio	zero,0(r5)
		  // Disable writing
		  IOWR_32DIRECT(PBUFF_WREN_BASE,0,0);
 4040204:	18000035 	stwio	zero,0(r3)
 *  clrBuffer()
 *  Clears the pixel buffer. Used to clear screen
 *  when processor restarts/program initialises
 */
void clrBuffer() {
	for (int i = 0; i < BUF_MAX_PIX; i++) {
 4040208:	10800044 	addi	r2,r2,1
 404020c:	113ffa1e 	bne	r2,r4,40401f8 <__flash_rwdata_start+0xfffff7f0>
		  IOWR_32DIRECT(PB_DATA_BASE,0,0);
		  // Disable writing
		  IOWR_32DIRECT(PBUFF_WREN_BASE,0,0);
	  }
	return;
}
 4040210:	f800283a 	ret

04040214 <writeImage>:
 * Writes the images in SDRAM to the pixel buffer
 * Uses the 2 LSBs to determine if the image should
 * be flipped when it is drawn
 * 0x1 is x flip, 0x2 is y flip
 */
void writeImage(char flipFlags) {
 4040214:	defff804 	addi	sp,sp,-32
 4040218:	dc000015 	stw	r16,0(sp)
 404021c:	2021883a 	mov	r16,r4
	alt_putstr("WRITING IMAGE TO BUFFER\n");
 4040220:	01008034 	movhi	r4,512
 4040224:	21000004 	addi	r4,r4,0
 * Writes the images in SDRAM to the pixel buffer
 * Uses the 2 LSBs to determine if the image should
 * be flipped when it is drawn
 * 0x1 is x flip, 0x2 is y flip
 */
void writeImage(char flipFlags) {
 4040228:	dfc00715 	stw	ra,28(sp)
 404022c:	dd800615 	stw	r22,24(sp)
 4040230:	dd400515 	stw	r21,20(sp)
 4040234:	dd000415 	stw	r20,16(sp)
 4040238:	dcc00315 	stw	r19,12(sp)
 404023c:	dc800215 	stw	r18,8(sp)
 4040240:	dc400115 	stw	r17,4(sp)
	alt_putstr("WRITING IMAGE TO BUFFER\n");
 4040244:	40408180 	call	4040818 <alt_putstr>
	alt_printf("Flags %x\n",flipFlags);
 4040248:	81403fcc 	andi	r5,r16,255
 404024c:	2940201c 	xori	r5,r5,128
 4040250:	01008034 	movhi	r4,512
 4040254:	297fe004 	addi	r5,r5,-128
 4040258:	21000704 	addi	r4,r4,28
 404025c:	40406600 	call	4040660 <alt_printf>
	int heightAddr = BUF_LAST_ROW_ADDR-1;

	// Setup Temp Data variables
	int data1;
	int data2;
	char xFlipped = (flipFlags & 0x1) != 0;
 4040260:	8080004c 	andi	r2,r16,1
 4040264:	8400008c 	andi	r16,r16,2
	// To correct this we check if the image is requested to be
	// flipped in y only. If it is we flip the x direction back
	// to correct for the errant x flip.
	// If y is not needed to be flipped, we only flip if x needs
	// to be flipped
	char performXFlip = yFlipped ? xFlipped^yFlipped : xFlipped;
 4040268:	80000426 	beq	r16,zero,404027c <writeImage+0x68>
 404026c:	1180005c 	xori	r6,r2,1
 4040270:	043fffc4 	movi	r16,-1

	// Define Base For Flip and add offset if required
	int base = 0;
	if (yFlipped) {
		base += heightAddr;
 4040274:	009297c4 	movi	r2,19039
 4040278:	00000306 	br	4040288 <writeImage+0x74>
 404027c:	100d883a 	mov	r6,r2
 4040280:	04000044 	movi	r16,1
	// If y is not needed to be flipped, we only flip if x needs
	// to be flipped
	char performXFlip = yFlipped ? xFlipped^yFlipped : xFlipped;

	// Define Base For Flip and add offset if required
	int base = 0;
 4040284:	0005883a 	mov	r2,zero
 4040288:	814027e4 	muli	r5,r16,159
			// Get the data from this pixel addresses above
			data1 = IORD_32DIRECT(SDRAM_BASEADDR,readOffset1*4)>>24;
			data2 = IORD_32DIRECT(SDRAM_BASEADDR,readOffset2*4)>>24;

			// Write the first pixel to the correct location in the buffer
			IOWR_32DIRECT(PB_ADR_BASE,0,(performXFlip ? pixelAddr2 : pixelAddr1));
 404028c:	31803fcc 	andi	r6,r6,255
 4040290:	87c02824 	muli	ra,r16,160
 4040294:	3180201c 	xori	r6,r6,128
 4040298:	04810234 	movhi	r18,1032
			IOWR_32DIRECT(PBUFF_WREN_BASE,0,1);
 404029c:	03800044 	movi	r14,1
 40402a0:	03c10234 	movhi	r15,1032
			IOWR_32DIRECT(PB_DATA_BASE,0,data1);
 40402a4:	04c10234 	movhi	r19,1032
	int readOffset2;
	int pixelAddr1;
	int pixelAddr2;

	// Loop to draw the image to the screen
	for (int i = 0; i < heightAddr; i = i + IMG_WIDTH) {
 40402a8:	05800074 	movhi	r22,1
 40402ac:	288b883a 	add	r5,r5,r2
			IOWR_32DIRECT(PBUFF_WREN_BASE,0,1);
			IOWR_32DIRECT(PB_DATA_BASE,0,data1);
			IOWR_32DIRECT(PBUFF_WREN_BASE,0,0);

			// Write the first pixel to the correct location in the buffer
			IOWR_32DIRECT(PB_ADR_BASE,0,(performXFlip ? pixelAddr1 : pixelAddr2));
 40402b0:	0007883a 	mov	r3,zero
			// Get the data from this pixel addresses above
			data1 = IORD_32DIRECT(SDRAM_BASEADDR,readOffset1*4)>>24;
			data2 = IORD_32DIRECT(SDRAM_BASEADDR,readOffset2*4)>>24;

			// Write the first pixel to the correct location in the buffer
			IOWR_32DIRECT(PB_ADR_BASE,0,(performXFlip ? pixelAddr2 : pixelAddr1));
 40402b4:	31bfe004 	addi	r6,r6,-128
 40402b8:	94841004 	addi	r18,r18,4160
			IOWR_32DIRECT(PBUFF_WREN_BASE,0,1);
 40402bc:	7bc40804 	addi	r15,r15,4128
			IOWR_32DIRECT(PB_DATA_BASE,0,data1);
 40402c0:	9cc40c04 	addi	r19,r19,4144
 40402c4:	7029883a 	mov	r20,r14
	int pixelAddr1;
	int pixelAddr2;

	// Loop to draw the image to the screen
	for (int i = 0; i < heightAddr; i = i + IMG_WIDTH) {
		for (int j = 0; j < IMG_WIDTH/2; j++){
 40402c8:	05405004 	movi	r21,320
	int readOffset2;
	int pixelAddr1;
	int pixelAddr2;

	// Loop to draw the image to the screen
	for (int i = 0; i < heightAddr; i = i + IMG_WIDTH) {
 40402cc:	b58a6004 	addi	r22,r22,10624
	char performXFlip = yFlipped ? xFlipped^yFlipped : xFlipped;

	// Define Base For Flip and add offset if required
	int base = 0;
	if (yFlipped) {
		base += heightAddr;
 40402d0:	0011883a 	mov	r8,zero
 40402d4:	000f883a 	mov	r7,zero
 40402d8:	0009883a 	mov	r4,zero
			pixelAddr1 = base+readOffset1*(yFlipped ? -1 : 1);
			pixelAddr2 = base+readOffset2*(yFlipped ? -1 : 1);

			// Get the data from this pixel addresses above
			data1 = IORD_32DIRECT(SDRAM_BASEADDR,readOffset1*4)>>24;
			data2 = IORD_32DIRECT(SDRAM_BASEADDR,readOffset2*4)>>24;
 40402dc:	1c409f04 	addi	r17,r3,636
 40402e0:	11d5883a 	add	r10,r2,r7
 40402e4:	4159883a 	add	r12,r8,r5
			// Calculate which pixel to read
			pixelAddr1 = base+readOffset1*(yFlipped ? -1 : 1);
			pixelAddr2 = base+readOffset2*(yFlipped ? -1 : 1);

			// Get the data from this pixel addresses above
			data1 = IORD_32DIRECT(SDRAM_BASEADDR,readOffset1*4)>>24;
 40402e8:	20d3883a 	add	r9,r4,r3
 40402ec:	4ac00037 	ldwio	r11,0(r9)
 40402f0:	5817d63a 	srai	r11,r11,24
			data2 = IORD_32DIRECT(SDRAM_BASEADDR,readOffset2*4)>>24;
 40402f4:	8913c83a 	sub	r9,r17,r4
 40402f8:	4a400037 	ldwio	r9,0(r9)
 40402fc:	4813d63a 	srai	r9,r9,24

			// Write the first pixel to the correct location in the buffer
			IOWR_32DIRECT(PB_ADR_BASE,0,(performXFlip ? pixelAddr2 : pixelAddr1));
 4040300:	3000021e 	bne	r6,zero,404030c <writeImage+0xf8>
 4040304:	501b883a 	mov	r13,r10
 4040308:	00000106 	br	4040310 <writeImage+0xfc>
 404030c:	601b883a 	mov	r13,r12
 4040310:	93400035 	stwio	r13,0(r18)
			IOWR_32DIRECT(PBUFF_WREN_BASE,0,1);
 4040314:	7b800035 	stwio	r14,0(r15)
			IOWR_32DIRECT(PB_DATA_BASE,0,data1);
 4040318:	9ac00035 	stwio	r11,0(r19)
			IOWR_32DIRECT(PBUFF_WREN_BASE,0,0);
 404031c:	78000035 	stwio	zero,0(r15)
 4040320:	02c10234 	movhi	r11,1032
 4040324:	5ac40804 	addi	r11,r11,4128

			// Write the first pixel to the correct location in the buffer
			IOWR_32DIRECT(PB_ADR_BASE,0,(performXFlip ? pixelAddr1 : pixelAddr2));
 4040328:	3000011e 	bne	r6,zero,4040330 <writeImage+0x11c>
 404032c:	6015883a 	mov	r10,r12
 4040330:	03010234 	movhi	r12,1032
 4040334:	63041004 	addi	r12,r12,4160
 4040338:	62800035 	stwio	r10,0(r12)
			IOWR_32DIRECT(PBUFF_WREN_BASE,0,1);
 404033c:	5d000035 	stwio	r20,0(r11)
			IOWR_32DIRECT(PB_DATA_BASE,0,data2);
 4040340:	02810234 	movhi	r10,1032
 4040344:	52840c04 	addi	r10,r10,4144
 4040348:	52400035 	stwio	r9,0(r10)
			IOWR_32DIRECT(PBUFF_WREN_BASE,0,0);
 404034c:	58000035 	stwio	zero,0(r11)
 4040350:	21000104 	addi	r4,r4,4
 4040354:	3c0f883a 	add	r7,r7,r16
 4040358:	4411c83a 	sub	r8,r8,r16
	int pixelAddr1;
	int pixelAddr2;

	// Loop to draw the image to the screen
	for (int i = 0; i < heightAddr; i = i + IMG_WIDTH) {
		for (int j = 0; j < IMG_WIDTH/2; j++){
 404035c:	257fe01e 	bne	r4,r21,40402e0 <__flash_rwdata_start+0xfffff8d8>
 4040360:	18c0a004 	addi	r3,r3,640
 4040364:	17c5883a 	add	r2,r2,ra
 4040368:	2fcb883a 	add	r5,r5,ra
	int readOffset2;
	int pixelAddr1;
	int pixelAddr2;

	// Loop to draw the image to the screen
	for (int i = 0; i < heightAddr; i = i + IMG_WIDTH) {
 404036c:	1dbfd81e 	bne	r3,r22,40402d0 <__flash_rwdata_start+0xfffff8c8>
			IOWR_32DIRECT(PB_DATA_BASE,0,data2);
			IOWR_32DIRECT(PBUFF_WREN_BASE,0,0);
		}
	}

	alt_putstr("WRITING COMPLETE\n");
 4040370:	01008034 	movhi	r4,512
 4040374:	21000a04 	addi	r4,r4,40
	return;
}
 4040378:	dfc00717 	ldw	ra,28(sp)
 404037c:	dd800617 	ldw	r22,24(sp)
 4040380:	dd400517 	ldw	r21,20(sp)
 4040384:	dd000417 	ldw	r20,16(sp)
 4040388:	dcc00317 	ldw	r19,12(sp)
 404038c:	dc800217 	ldw	r18,8(sp)
 4040390:	dc400117 	ldw	r17,4(sp)
 4040394:	dc000017 	ldw	r16,0(sp)
 4040398:	dec00804 	addi	sp,sp,32
			IOWR_32DIRECT(PB_DATA_BASE,0,data2);
			IOWR_32DIRECT(PBUFF_WREN_BASE,0,0);
		}
	}

	alt_putstr("WRITING COMPLETE\n");
 404039c:	40408181 	jmpi	4040818 <alt_putstr>

040403a0 <KEY_IN_ISR>:
 * Currently just checks which button was pressed,
 * updates the global flip flag accordingly and then
 * redraws the image to the screen
 */
void KEY_IN_ISR(void * isr_context, alt_u32 id)
{
 40403a0:	defffe04 	addi	sp,sp,-8
 40403a4:	dc000015 	stw	r16,0(sp)
 40403a8:	2021883a 	mov	r16,r4
	alt_putstr("Interrupt Triggered\n");
 40403ac:	01008034 	movhi	r4,512
 40403b0:	21000f04 	addi	r4,r4,60
 * Currently just checks which button was pressed,
 * updates the global flip flag accordingly and then
 * redraws the image to the screen
 */
void KEY_IN_ISR(void * isr_context, alt_u32 id)
{
 40403b4:	dfc00115 	stw	ra,4(sp)
	alt_putstr("Interrupt Triggered\n");
 40403b8:	40408180 	call	4040818 <alt_putstr>
	// Retrieve the memory address to store the edge capture data
	volatile int* button_edge_capture_ptr = (volatile int*) isr_context;
	// Get edge capture data
	*button_edge_capture_ptr = IORD_ALTERA_AVALON_PIO_EDGE_CAP(KEY_IN_BASE);
 40403bc:	00810234 	movhi	r2,1032
 40403c0:	10841704 	addi	r2,r2,4188
 40403c4:	10c00037 	ldwio	r3,0(r2)
 40403c8:	80c00015 	stw	r3,0(r16)
	// Write to the edge capture register to reset it.
	IOWR_ALTERA_AVALON_PIO_EDGE_CAP(KEY_IN_BASE, 0);
 40403cc:	10000035 	stwio	zero,0(r2)
	// Flip the flag in the global variable as required and redraw image
	flipImgFlags = flipImgFlags ^ (*button_edge_capture_ptr);
 40403d0:	81000017 	ldw	r4,0(r16)
 40403d4:	d0a00303 	ldbu	r2,-32756(gp)
 40403d8:	2088f03a 	xor	r4,r4,r2
 40403dc:	d1200305 	stb	r4,-32756(gp)
	writeImage(flipImgFlags);
 40403e0:	21003fcc 	andi	r4,r4,255
 40403e4:	2100201c 	xori	r4,r4,128
 40403e8:	213fe004 	addi	r4,r4,-128
}
 40403ec:	dfc00117 	ldw	ra,4(sp)
 40403f0:	dc000017 	ldw	r16,0(sp)
 40403f4:	dec00204 	addi	sp,sp,8
	*button_edge_capture_ptr = IORD_ALTERA_AVALON_PIO_EDGE_CAP(KEY_IN_BASE);
	// Write to the edge capture register to reset it.
	IOWR_ALTERA_AVALON_PIO_EDGE_CAP(KEY_IN_BASE, 0);
	// Flip the flag in the global variable as required and redraw image
	flipImgFlags = flipImgFlags ^ (*button_edge_capture_ptr);
	writeImage(flipImgFlags);
 40403f8:	40402141 	jmpi	4040214 <writeImage>

040403fc <main>:
 * - Clears the buffer
 * - Draws the initial image to the screen
 */
int main()
{ 
	alt_putstr("Begin VGA\n");
 40403fc:	01008034 	movhi	r4,512
 * - Sets up the interrupt handler
 * - Clears the buffer
 * - Draws the initial image to the screen
 */
int main()
{ 
 4040400:	defffe04 	addi	sp,sp,-8
	alt_putstr("Begin VGA\n");
 4040404:	21001504 	addi	r4,r4,84
 * - Sets up the interrupt handler
 * - Clears the buffer
 * - Draws the initial image to the screen
 */
int main()
{ 
 4040408:	dfc00115 	stw	ra,4(sp)
	alt_putstr("Begin VGA\n");
 404040c:	40408180 	call	4040818 <alt_putstr>

	// Clear buffer
	clrBuffer();
 4040410:	40401d40 	call	40401d4 <clrBuffer>

	// Draw the Initial Image
	writeImage(0x0);
 4040414:	0009883a 	mov	r4,zero
 4040418:	40402140 	call	4040214 <writeImage>

	// Init Interrupt
	alt_putstr("INIT IRQ\n");
 404041c:	01008034 	movhi	r4,512
 4040420:	21001804 	addi	r4,r4,96
 4040424:	40408180 	call	4040818 <alt_putstr>
{
	// Recast the edge_capture pointer to match the
	//alt_irq_register() function prototype.
	void* button_edge_capture_ptr = (void*) &edge_capture;
	// Enable interrupts for both kes
	IOWR_ALTERA_AVALON_PIO_IRQ_MASK(KEY_IN_BASE, 0x3);
 4040428:	00810234 	movhi	r2,1032
 404042c:	014000c4 	movi	r5,3
 4040430:	10841604 	addi	r2,r2,4184
 4040434:	11400035 	stwio	r5,0(r2)
	// Reset the edge capture register.
	IOWR_ALTERA_AVALON_PIO_EDGE_CAP(KEY_IN_BASE, 0x0);
 4040438:	00810234 	movhi	r2,1032
 404043c:	10841704 	addi	r2,r2,4188
 4040440:	10000035 	stwio	zero,0(r2)
	// Register the ISR.
	alt_ic_isr_register(
 4040444:	01810134 	movhi	r6,1028
 4040448:	d8000015 	stw	zero,0(sp)
 404044c:	d1e00404 	addi	r7,gp,-32752
 4040450:	3180e804 	addi	r6,r6,928
 4040454:	0009883a 	mov	r4,zero
 4040458:	40404600 	call	4040460 <alt_ic_isr_register>
 404045c:	003fff06 	br	404045c <__flash_rwdata_start+0xfffffa54>

04040460 <alt_ic_isr_register>:
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 4040460:	40404ec1 	jmpi	40404ec <alt_iic_isr_register>

04040464 <alt_ic_irq_enable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 4040464:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4040468:	00bfff84 	movi	r2,-2
 404046c:	2084703a 	and	r2,r4,r2
 4040470:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
 4040474:	00c00044 	movi	r3,1
 4040478:	d0a00517 	ldw	r2,-32748(gp)
 404047c:	194a983a 	sll	r5,r3,r5
 4040480:	288ab03a 	or	r5,r5,r2
 4040484:	d1600515 	stw	r5,-32748(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 4040488:	d0a00517 	ldw	r2,-32748(gp)
 404048c:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 4040490:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_enable(irq);
}
 4040494:	0005883a 	mov	r2,zero
 4040498:	f800283a 	ret

0404049c <alt_ic_irq_disable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 404049c:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 40404a0:	00bfff84 	movi	r2,-2
 40404a4:	2084703a 	and	r2,r4,r2
 40404a8:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active &= ~(1 << id);
 40404ac:	00ffff84 	movi	r3,-2
 40404b0:	d0a00517 	ldw	r2,-32748(gp)
 40404b4:	194a183a 	rol	r5,r3,r5
 40404b8:	288a703a 	and	r5,r5,r2
 40404bc:	d1600515 	stw	r5,-32748(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 40404c0:	d0a00517 	ldw	r2,-32748(gp)
 40404c4:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 40404c8:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_disable(irq);
}
 40404cc:	0005883a 	mov	r2,zero
 40404d0:	f800283a 	ret

040404d4 <alt_ic_irq_enabled>:
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 40404d4:	000730fa 	rdctl	r3,ienable

    return (irq_enabled & (1 << irq)) ? 1: 0;
 40404d8:	00800044 	movi	r2,1
 40404dc:	1144983a 	sll	r2,r2,r5
 40404e0:	10c4703a 	and	r2,r2,r3
}
 40404e4:	1004c03a 	cmpne	r2,r2,zero
 40404e8:	f800283a 	ret

040404ec <alt_iic_isr_register>:
{
  int rc = -EINVAL;  
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  alt_irq_context status;

  if (id < ALT_NIRQ)
 40404ec:	00c007c4 	movi	r3,31
 40404f0:	19401616 	blt	r3,r5,404054c <alt_iic_isr_register+0x60>
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 40404f4:	defffe04 	addi	sp,sp,-8
 40404f8:	dfc00115 	stw	ra,4(sp)
 40404fc:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 4040500:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4040504:	00ffff84 	movi	r3,-2
 4040508:	80c6703a 	and	r3,r16,r3
 404050c:	1801703a 	wrctl	status,r3
     * state.
     */

    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
 4040510:	280490fa 	slli	r2,r5,3
 4040514:	00c08034 	movhi	r3,512
 4040518:	18c02504 	addi	r3,r3,148
 404051c:	1885883a 	add	r2,r3,r2
 4040520:	11800015 	stw	r6,0(r2)
    alt_irq[id].context = isr_context;
 4040524:	11c00115 	stw	r7,4(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 4040528:	30000226 	beq	r6,zero,4040534 <alt_iic_isr_register+0x48>
 404052c:	40404640 	call	4040464 <alt_ic_irq_enable>
 4040530:	00000106 	br	4040538 <alt_iic_isr_register+0x4c>
 4040534:	404049c0 	call	404049c <alt_ic_irq_disable>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 4040538:	8001703a 	wrctl	status,r16

    alt_irq_enable_all(status);
  }

  return rc; 
}
 404053c:	dfc00117 	ldw	ra,4(sp)
 4040540:	dc000017 	ldw	r16,0(sp)
 4040544:	dec00204 	addi	sp,sp,8
 4040548:	f800283a 	ret
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  int rc = -EINVAL;  
 404054c:	00bffa84 	movi	r2,-22
 4040550:	f800283a 	ret

04040554 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 4040554:	deffff04 	addi	sp,sp,-4
 4040558:	01008034 	movhi	r4,512
 404055c:	01410134 	movhi	r5,1028
 4040560:	dfc00015 	stw	ra,0(sp)
 4040564:	21001b04 	addi	r4,r4,108
 4040568:	29428204 	addi	r5,r5,2568

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
 404056c:	2140061e 	bne	r4,r5,4040588 <alt_load+0x34>
 4040570:	01010134 	movhi	r4,1028
 4040574:	01410134 	movhi	r5,1028
 4040578:	21000804 	addi	r4,r4,32
 404057c:	29400804 	addi	r5,r5,32
 4040580:	2140121e 	bne	r4,r5,40405cc <alt_load+0x78>
 4040584:	00000b06 	br	40405b4 <alt_load+0x60>
 4040588:	00c08034 	movhi	r3,512
 404058c:	18c01e04 	addi	r3,r3,120
 4040590:	1907c83a 	sub	r3,r3,r4
 4040594:	0005883a 	mov	r2,zero
  {
    while( to != end )
 4040598:	10fff526 	beq	r2,r3,4040570 <__flash_rwdata_start+0xfffffb68>
    {
      *to++ = *from++;
 404059c:	114f883a 	add	r7,r2,r5
 40405a0:	39c00017 	ldw	r7,0(r7)
 40405a4:	110d883a 	add	r6,r2,r4
 40405a8:	10800104 	addi	r2,r2,4
 40405ac:	31c00015 	stw	r7,0(r6)
 40405b0:	003ff906 	br	4040598 <__flash_rwdata_start+0xfffffb90>
 40405b4:	01008034 	movhi	r4,512
 40405b8:	01410134 	movhi	r5,1028
 40405bc:	21000004 	addi	r4,r4,0
 40405c0:	29426704 	addi	r5,r5,2460

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
 40405c4:	2140101e 	bne	r4,r5,4040608 <alt_load+0xb4>
 40405c8:	00000b06 	br	40405f8 <alt_load+0xa4>
 40405cc:	00c10134 	movhi	r3,1028
 40405d0:	18c06204 	addi	r3,r3,392
 40405d4:	1907c83a 	sub	r3,r3,r4
 40405d8:	0005883a 	mov	r2,zero
  {
    while( to != end )
 40405dc:	10fff526 	beq	r2,r3,40405b4 <__flash_rwdata_start+0xfffffbac>
    {
      *to++ = *from++;
 40405e0:	114f883a 	add	r7,r2,r5
 40405e4:	39c00017 	ldw	r7,0(r7)
 40405e8:	110d883a 	add	r6,r2,r4
 40405ec:	10800104 	addi	r2,r2,4
 40405f0:	31c00015 	stw	r7,0(r6)
 40405f4:	003ff906 	br	40405dc <__flash_rwdata_start+0xfffffbd4>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 40405f8:	40408a80 	call	40408a8 <alt_dcache_flush_all>
  alt_icache_flush_all();
}
 40405fc:	dfc00017 	ldw	ra,0(sp)
 4040600:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
 4040604:	40408c01 	jmpi	40408c0 <alt_icache_flush_all>
 4040608:	00c08034 	movhi	r3,512
 404060c:	18c01b04 	addi	r3,r3,108
 4040610:	1907c83a 	sub	r3,r3,r4

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
 4040614:	0005883a 	mov	r2,zero
  {
    while( to != end )
 4040618:	18bff726 	beq	r3,r2,40405f8 <__flash_rwdata_start+0xfffffbf0>
    {
      *to++ = *from++;
 404061c:	114f883a 	add	r7,r2,r5
 4040620:	39c00017 	ldw	r7,0(r7)
 4040624:	110d883a 	add	r6,r2,r4
 4040628:	10800104 	addi	r2,r2,4
 404062c:	31c00015 	stw	r7,0(r6)
 4040630:	003ff906 	br	4040618 <__flash_rwdata_start+0xfffffc10>

04040634 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 4040634:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 4040638:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 404063c:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 4040640:	40408500 	call	4040850 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 4040644:	40408700 	call	4040870 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
 4040648:	d1a00617 	ldw	r6,-32744(gp)
 404064c:	d1600717 	ldw	r5,-32740(gp)
 4040650:	d1200817 	ldw	r4,-32736(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
 4040654:	dfc00017 	ldw	ra,0(sp)
 4040658:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
 404065c:	40403fc1 	jmpi	40403fc <main>

04040660 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
 4040660:	defff204 	addi	sp,sp,-56
 4040664:	2005883a 	mov	r2,r4
 4040668:	dfc00a15 	stw	ra,40(sp)
 404066c:	df000915 	stw	fp,36(sp)
 4040670:	ddc00815 	stw	r23,32(sp)
 4040674:	dd800715 	stw	r22,28(sp)
 4040678:	dd400615 	stw	r21,24(sp)
 404067c:	dd000515 	stw	r20,20(sp)
 4040680:	dcc00415 	stw	r19,16(sp)
 4040684:	dc800315 	stw	r18,12(sp)
 4040688:	dc400215 	stw	r17,8(sp)
 404068c:	dc000115 	stw	r16,4(sp)
 4040690:	d9400b15 	stw	r5,44(sp)
 4040694:	d9800c15 	stw	r6,48(sp)
 4040698:	d9c00d15 	stw	r7,52(sp)
    w = fmt;
    while ((c = *w++) != 0)
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
 404069c:	04000944 	movi	r16,37
 */
void 
alt_printf(const char* fmt, ... )
{
	va_list args;
	va_start(args, fmt);
 40406a0:	dd400b04 	addi	r21,sp,44
                if (c == '%')
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
 40406a4:	048018c4 	movi	r18,99
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
                }
                else if (c == 'x')
 40406a8:	04c01e04 	movi	r19,120
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
 40406ac:	05001cc4 	movi	r20,115
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
 40406b0:	11000007 	ldb	r4,0(r2)
 40406b4:	20003a26 	beq	r4,zero,40407a0 <alt_printf+0x140>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
 40406b8:	24000226 	beq	r4,r16,40406c4 <alt_printf+0x64>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
 40406bc:	14400044 	addi	r17,r2,1
 40406c0:	00001406 	br	4040714 <alt_printf+0xb4>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
 40406c4:	14400084 	addi	r17,r2,2
 40406c8:	10800047 	ldb	r2,1(r2)
 40406cc:	10003426 	beq	r2,zero,40407a0 <alt_printf+0x140>
            {
                if (c == '%')
 40406d0:	1400021e 	bne	r2,r16,40406dc <alt_printf+0x7c>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
 40406d4:	8009883a 	mov	r4,r16
 40406d8:	00000e06 	br	4040714 <alt_printf+0xb4>
                } 
                else if (c == 'c')
 40406dc:	1480051e 	bne	r2,r18,40406f4 <alt_printf+0x94>
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
 40406e0:	a9000017 	ldw	r4,0(r21)
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
                {
                    int v = va_arg(args, int);
 40406e4:	ad800104 	addi	r22,r21,4
 40406e8:	b02b883a 	mov	r21,r22
                    alt_putchar(v);
 40406ec:	40407d00 	call	40407d0 <alt_putchar>
 40406f0:	00002906 	br	4040798 <alt_printf+0x138>
                }
                else if (c == 'x')
 40406f4:	14c0201e 	bne	r2,r19,4040778 <alt_printf+0x118>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
 40406f8:	adc00017 	ldw	r23,0(r21)
 40406fc:	ad400104 	addi	r21,r21,4
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
 4040700:	b8000326 	beq	r23,zero,4040710 <alt_printf+0xb0>
 4040704:	05800704 	movi	r22,28
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
 4040708:	00c003c4 	movi	r3,15
 404070c:	00000306 	br	404071c <alt_printf+0xbc>
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
                    {
                        alt_putchar('0');
 4040710:	01000c04 	movi	r4,48
 4040714:	40407d00 	call	40407d0 <alt_putchar>
                        continue;
 4040718:	00001f06 	br	4040798 <alt_printf+0x138>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
 404071c:	1d84983a 	sll	r2,r3,r22
 4040720:	15c4703a 	and	r2,r2,r23
 4040724:	1000021e 	bne	r2,zero,4040730 <alt_printf+0xd0>
                        digit_shift -= 4;
 4040728:	b5bfff04 	addi	r22,r22,-4
 404072c:	003ffb06 	br	404071c <__flash_rwdata_start+0xfffffd14>

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
 4040730:	070003c4 	movi	fp,15
                        if (digit <= 9)
 4040734:	00c00244 	movi	r3,9
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
 4040738:	b0001716 	blt	r22,zero,4040798 <alt_printf+0x138>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
 404073c:	e588983a 	sll	r4,fp,r22
 4040740:	25c8703a 	and	r4,r4,r23
 4040744:	2588d83a 	srl	r4,r4,r22
                        if (digit <= 9)
 4040748:	19000236 	bltu	r3,r4,4040754 <alt_printf+0xf4>
                            c = '0' + digit;
 404074c:	21000c04 	addi	r4,r4,48
 4040750:	00000106 	br	4040758 <alt_printf+0xf8>
                        else
                            c = 'a' + digit - 10;
 4040754:	210015c4 	addi	r4,r4,87
                        alt_putchar(c);
 4040758:	21003fcc 	andi	r4,r4,255
 404075c:	2100201c 	xori	r4,r4,128
 4040760:	213fe004 	addi	r4,r4,-128
 4040764:	d8c00015 	stw	r3,0(sp)
 4040768:	40407d00 	call	40407d0 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
 404076c:	b5bfff04 	addi	r22,r22,-4
 4040770:	d8c00017 	ldw	r3,0(sp)
 4040774:	003ff006 	br	4040738 <__flash_rwdata_start+0xfffffd30>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
 4040778:	1500071e 	bne	r2,r20,4040798 <alt_printf+0x138>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
 404077c:	ad800017 	ldw	r22,0(r21)
 4040780:	ad400104 	addi	r21,r21,4

                    while(*s)
 4040784:	b1000007 	ldb	r4,0(r22)
 4040788:	20000326 	beq	r4,zero,4040798 <alt_printf+0x138>
                      alt_putchar(*s++);
 404078c:	b5800044 	addi	r22,r22,1
 4040790:	40407d00 	call	40407d0 <alt_putchar>
 4040794:	003ffb06 	br	4040784 <__flash_rwdata_start+0xfffffd7c>
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
                {
                    int v = va_arg(args, int);
 4040798:	8805883a 	mov	r2,r17
 404079c:	003fc406 	br	40406b0 <__flash_rwdata_start+0xfffffca8>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
 40407a0:	dfc00a17 	ldw	ra,40(sp)
 40407a4:	df000917 	ldw	fp,36(sp)
 40407a8:	ddc00817 	ldw	r23,32(sp)
 40407ac:	dd800717 	ldw	r22,28(sp)
 40407b0:	dd400617 	ldw	r21,24(sp)
 40407b4:	dd000517 	ldw	r20,20(sp)
 40407b8:	dcc00417 	ldw	r19,16(sp)
 40407bc:	dc800317 	ldw	r18,12(sp)
 40407c0:	dc400217 	ldw	r17,8(sp)
 40407c4:	dc000117 	ldw	r16,4(sp)
 40407c8:	dec00e04 	addi	sp,sp,56
 40407cc:	f800283a 	ret

040407d0 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
 40407d0:	defffd04 	addi	sp,sp,-12
 40407d4:	dc000115 	stw	r16,4(sp)
	char        c1 = (char)(c & 0xff);
    return write(STDOUT_FILENO,&c1,1);
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);
 40407d8:	d9000005 	stb	r4,0(sp)
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
 40407dc:	2021883a 	mov	r16,r4
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);

    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
 40407e0:	01008034 	movhi	r4,512
 40407e4:	000f883a 	mov	r7,zero
 40407e8:	01800044 	movi	r6,1
 40407ec:	d80b883a 	mov	r5,sp
 40407f0:	21001d04 	addi	r4,r4,116
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
 40407f4:	dfc00215 	stw	ra,8(sp)
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);

    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
 40407f8:	40408740 	call	4040874 <altera_avalon_jtag_uart_write>
 40407fc:	00ffffc4 	movi	r3,-1
 4040800:	10c00126 	beq	r2,r3,4040808 <alt_putchar+0x38>
        return -1;
    }
    return c;
 4040804:	8005883a 	mov	r2,r16
#else
    return putchar(c);
#endif
#endif
}
 4040808:	dfc00217 	ldw	ra,8(sp)
 404080c:	dc000117 	ldw	r16,4(sp)
 4040810:	dec00304 	addi	sp,sp,12
 4040814:	f800283a 	ret

04040818 <alt_putstr>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided fputs() routine.
 */
int 
alt_putstr(const char* str)
{
 4040818:	defffe04 	addi	sp,sp,-8
 404081c:	dc000015 	stw	r16,0(sp)
 4040820:	dfc00115 	stw	ra,4(sp)
 4040824:	2021883a 	mov	r16,r4
#ifdef ALT_SEMIHOSTING
    return write(STDOUT_FILENO,str,strlen(str));
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, str, strlen(str), 0);
 4040828:	40409800 	call	4040980 <strlen>
 404082c:	01008034 	movhi	r4,512
 4040830:	000f883a 	mov	r7,zero
 4040834:	100d883a 	mov	r6,r2
 4040838:	800b883a 	mov	r5,r16
 404083c:	21001d04 	addi	r4,r4,116
#else
    return fputs(str, stdout);
#endif
#endif
}
 4040840:	dfc00117 	ldw	ra,4(sp)
 4040844:	dc000017 	ldw	r16,0(sp)
 4040848:	dec00204 	addi	sp,sp,8
#ifdef ALT_SEMIHOSTING
    return write(STDOUT_FILENO,str,strlen(str));
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, str, strlen(str), 0);
 404084c:	40408741 	jmpi	4040874 <altera_avalon_jtag_uart_write>

04040850 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 4040850:	deffff04 	addi	sp,sp,-4
 4040854:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS_PROC, NIOS_PROC);
 4040858:	40409400 	call	4040940 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 404085c:	00800044 	movi	r2,1
 4040860:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 4040864:	dfc00017 	ldw	ra,0(sp)
 4040868:	dec00104 	addi	sp,sp,4
 404086c:	f800283a 	ret

04040870 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 4040870:	f800283a 	ret

04040874 <altera_avalon_jtag_uart_write>:
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
 4040874:	21000017 	ldw	r4,0(r4)
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 4040878:	3005883a 	mov	r2,r6
  unsigned int base = sp->base;

  const char * end = ptr + count;
 404087c:	298d883a 	add	r6,r5,r6

  while (ptr < end)
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
 4040880:	21c00104 	addi	r7,r4,4
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
 4040884:	2980072e 	bgeu	r5,r6,40408a4 <altera_avalon_jtag_uart_write+0x30>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
 4040888:	38c00037 	ldwio	r3,0(r7)
 404088c:	18ffffec 	andhi	r3,r3,65535
 4040890:	183ffc26 	beq	r3,zero,4040884 <__flash_rwdata_start+0xfffffe7c>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
 4040894:	28c00007 	ldb	r3,0(r5)
 4040898:	20c00035 	stwio	r3,0(r4)
 404089c:	29400044 	addi	r5,r5,1
 40408a0:	003ff806 	br	4040884 <__flash_rwdata_start+0xfffffe7c>

  return count;
}
 40408a4:	f800283a 	ret

040408a8 <alt_dcache_flush_all>:
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 40408a8:	0005883a 	mov	r2,zero
 40408ac:	00c20004 	movi	r3,2048
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
 40408b0:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 40408b4:	10800804 	addi	r2,r2,32
 40408b8:	10fffd1e 	bne	r2,r3,40408b0 <__flash_rwdata_start+0xfffffea8>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 40408bc:	f800283a 	ret

040408c0 <alt_icache_flush_all>:
 */

void alt_icache_flush_all (void)
{
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
 40408c0:	01440004 	movi	r5,4096
 40408c4:	0009883a 	mov	r4,zero
 40408c8:	40409481 	jmpi	4040948 <alt_icache_flush>

040408cc <alt_exception_cause_generated_bad_addr>:
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
  switch (cause) {
 40408cc:	213ffe84 	addi	r4,r4,-6
 40408d0:	008003c4 	movi	r2,15
 40408d4:	11001636 	bltu	r2,r4,4040930 <alt_exception_cause_generated_bad_addr+0x64>
 40408d8:	200890ba 	slli	r4,r4,2
 40408dc:	00810134 	movhi	r2,1028
 40408e0:	10823c04 	addi	r2,r2,2288
 40408e4:	2089883a 	add	r4,r4,r2
 40408e8:	20800017 	ldw	r2,0(r4)
 40408ec:	1000683a 	jmp	r2
 40408f0:	04040938 	rdprs	r16,zero,4132
 40408f4:	04040938 	rdprs	r16,zero,4132
 40408f8:	04040930 	cmpltui	r16,zero,4132
 40408fc:	04040930 	cmpltui	r16,zero,4132
 4040900:	04040930 	cmpltui	r16,zero,4132
 4040904:	04040938 	rdprs	r16,zero,4132
 4040908:	04040930 	cmpltui	r16,zero,4132
 404090c:	04040930 	cmpltui	r16,zero,4132
 4040910:	04040938 	rdprs	r16,zero,4132
 4040914:	04040938 	rdprs	r16,zero,4132
 4040918:	04040930 	cmpltui	r16,zero,4132
 404091c:	04040938 	rdprs	r16,zero,4132
 4040920:	04040930 	cmpltui	r16,zero,4132
 4040924:	04040930 	cmpltui	r16,zero,4132
 4040928:	04040930 	cmpltui	r16,zero,4132
 404092c:	04040938 	rdprs	r16,zero,4132
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
 4040930:	0005883a 	mov	r2,zero
 4040934:	f800283a 	ret
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
 4040938:	00800044 	movi	r2,1
    return 0;

  default:
    return 0;
  }
}
 404093c:	f800283a 	ret

04040940 <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
 4040940:	000170fa 	wrctl	ienable,zero
 4040944:	f800283a 	ret

04040948 <alt_icache_flush>:
  if (len > NIOS2_ICACHE_SIZE)
  {
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;
 4040948:	00840004 	movi	r2,4096
 404094c:	1140012e 	bgeu	r2,r5,4040954 <alt_icache_flush+0xc>
 4040950:	100b883a 	mov	r5,r2
 4040954:	214b883a 	add	r5,r4,r5

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 4040958:	2005883a 	mov	r2,r4
 404095c:	1140032e 	bgeu	r2,r5,404096c <alt_icache_flush+0x24>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
 4040960:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 4040964:	10800804 	addi	r2,r2,32
 4040968:	003ffc06 	br	404095c <__flash_rwdata_start+0xffffff54>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
 404096c:	210007cc 	andi	r4,r4,31
 4040970:	20000126 	beq	r4,zero,4040978 <alt_icache_flush+0x30>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
 4040974:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
 4040978:	0000203a 	flushp
 404097c:	f800283a 	ret

04040980 <strlen>:
 4040980:	2005883a 	mov	r2,r4
 4040984:	10c00007 	ldb	r3,0(r2)
 4040988:	18000226 	beq	r3,zero,4040994 <strlen+0x14>
 404098c:	10800044 	addi	r2,r2,1
 4040990:	003ffc06 	br	4040984 <__flash_rwdata_start+0xffffff7c>
 4040994:	1105c83a 	sub	r2,r2,r4
 4040998:	f800283a 	ret
