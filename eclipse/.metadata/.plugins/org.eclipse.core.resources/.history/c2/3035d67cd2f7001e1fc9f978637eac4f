#include "sys/alt_stdio.h"
#include "io.h"
#include <system.h>
#include "alt_types.h"
#include <sys/alt_irq.h>
#include "priv/alt_legacy_irq.h"
// Define SDRAM BASE
#define SDRAM_BASEADDR 0x0000000
// Define VGA Characteristics
#define IMG_WIDTH 160
#define BUF_LAST_ROW_ADDR 19040
#define BUF_MAX_PIX 19200

int * key_in_base = KEY_IN_BASE;
void * context;
void * flags;

/* Use system defines
 * PB_ADR_BASE
 * PB_DATA_BASE
 * PBUFF_WREN_BASE
 * SW_IN_BASE
 * LEDR_OUT_BASE
 * KEY_IN_BASE
 */

void clrBuffer() {
	for (int i = 0; i < BUF_MAX_PIX; i++) {
		  // Set Buffer Address
		  IOWR_32DIRECT(PB_ADR_BASE,0,i);
		  // Enable Writing
		  IOWR_32DIRECT(PBUFF_WREN_BASE,0,1);
		  // Write Data
		  IOWR_32DIRECT(PB_DATA_BASE,0,0);
		  // Disable writing
		  IOWR_32DIRECT(PBUFF_WREN_BASE,0,0);
	  }
	return;
}

// Function it uses the last 2 bits
// 0x1 is x flip, 0x2 is y flip
void writeImage(char flipFlags) {
	alt_putstr("WRITING IMAGE TO BUFFER\n");
	alt_printf("Flags %x\n",flipFlags);

	// Setup Draw Params
	int heightAddr = BUF_LAST_ROW_ADDR-1;

	// Setup Temp Data variables
	int data1;
	int data2;

	// Define Base For Flip
	int base = 0;
	if ((flipFlags & 0x2) != 0) {
		base += heightAddr-IMG_WIDTH;
	}

	int readOffset1;
	int readOffset2;

	int pixelAddr1;
	int pixelAddr2;

	// Flip in the x-direction
	if ((flipFlags & 0x1) != 0) {
		for (int i = 0; i < heightAddr; i = i + IMG_WIDTH) {
				for (int j = 0; j < IMG_WIDTH/2; j++){
					// offset1 ----->	<----- offset 2 //
					readOffset1 = i+j;
					readOffset2 = i + IMG_WIDTH - j - 1;

					pixelAddr1 = readOffset1;
					pixelAddr2 = readOffset2;

					data1 = IORD_32DIRECT(SDRAM_BASEADDR,readOffset1*4)>>24;
					data2 = IORD_32DIRECT(SDRAM_BASEADDR,readOffset2*4)>>24;

					IOWR_32DIRECT(PB_ADR_BASE,0,pixelAddr2);
					IOWR_32DIRECT(PBUFF_WREN_BASE,0,1);
					IOWR_32DIRECT(PB_DATA_BASE,0,data1);
					IOWR_32DIRECT(PBUFF_WREN_BASE,0,0);

					IOWR_32DIRECT(PB_ADR_BASE,0,pixelAddr1);
					IOWR_32DIRECT(PBUFF_WREN_BASE,0,1);
					IOWR_32DIRECT(PB_DATA_BASE,0,data2);
					IOWR_32DIRECT(PBUFF_WREN_BASE,0,0);
				}
			}
	} else
	// Don't flip in the x-direction
	{
		for (int i = 0; i < heightAddr; i = i + IMG_WIDTH) {
				for (int j = 0; j < IMG_WIDTH/2; j++){
					// offset1 ----->	<----- offset 2 //
					readOffset1 = i+j;
					readOffset2 = i + IMG_WIDTH - j - 1;

					pixelAddr1 = base+readOffset1;
					pixelAddr2 = base+readOffset2;

					data1 = IORD_32DIRECT(SDRAM_BASEADDR,readOffset1*4)>>24;
					data2 = IORD_32DIRECT(SDRAM_BASEADDR,readOffset2*4)>>24;

					IOWR_32DIRECT(PB_ADR_BASE,0,pixelAddr1);
					IOWR_32DIRECT(PBUFF_WREN_BASE,0,1);
					IOWR_32DIRECT(PB_DATA_BASE,0,data1);
					IOWR_32DIRECT(PBUFF_WREN_BASE,0,0);

					IOWR_32DIRECT(PB_ADR_BASE,0,pixelAddr2);
					IOWR_32DIRECT(PBUFF_WREN_BASE,0,1);
					IOWR_32DIRECT(PB_DATA_BASE,0,data2);
					IOWR_32DIRECT(PBUFF_WREN_BASE,0,0);
				}
			}
	}

	alt_putstr("WRITING COMPLETE\n");
	return;
}

void image_yflip(){
	int data1;
	int data2;
	int width = 160;
	int heightAddr = 19040;
	for (int i = 0; i < heightAddr; i = i + 160) {
		for (int j = 0; j < width/2; j++){
		  int offset1 = i+j;
		  int offset2 = i+ width - j - 1;
		  data1 = IORD_32DIRECT(SDRAM_BASEADDR,offset1*4)>>24;
		  data2 = IORD_32DIRECT(SDRAM_BASEADDR,offset2*4)>>24;
		  //data1 = IORD_32DIRECT(PB_ADR_BASE,offset1)
		  //data2 = IORD_32DIRECT(PB_ADR_BASE,offset2)
		  //Enable write

		  // Write Data

		  IOWR_32DIRECT(PB_ADR_BASE,0,offset2);
		  IOWR_32DIRECT(PBUFF_WREN_BASE,0,1);
		  IOWR_32DIRECT(PB_DATA_BASE,0,data1);
		  IOWR_32DIRECT(PBUFF_WREN_BASE,0,0);

		  IOWR_32DIRECT(PB_ADR_BASE,0,offset1);
		  IOWR_32DIRECT(PBUFF_WREN_BASE,0,1);
		  IOWR_32DIRECT(PB_DATA_BASE,0,data2);
		  IOWR_32DIRECT(PBUFF_WREN_BASE,0,0);
	  }
	}
	alt_putstr("Y FlIP COMPLETE\n");
}

void image_xflip(){
	int data1;
	int data2;
	int width = 160;
	int heightAddr = 19040;
	for (int i = 0; i < heightAddr/2; i = i + 160) {
		for (int j = 0; j < width; j++){
		  int offset1 = i+j;
		  int offset2 = heightAddr + j - i - 1;
		  data1 = IORD_32DIRECT(SDRAM_BASEADDR,offset1*4)>>24;
		  data2 = IORD_32DIRECT(SDRAM_BASEADDR,offset2*4)>>24;

		  //Enable write
		  // Write Data
		  IOWR_32DIRECT(PB_ADR_BASE,0,offset2);
		  IOWR_32DIRECT(PBUFF_WREN_BASE,0,1);
		  IOWR_32DIRECT(PB_DATA_BASE,0,data1);
		  IOWR_32DIRECT(PBUFF_WREN_BASE,0,0);

		  IOWR_32DIRECT(PB_ADR_BASE,0,offset1);
		  IOWR_32DIRECT(PBUFF_WREN_BASE,0,1);
		  IOWR_32DIRECT(PB_DATA_BASE,0,data2);
		  IOWR_32DIRECT(PBUFF_WREN_BASE,0,0);
	  }
	}
	alt_putstr("X FlIP COMPLETE\n");
}

void KEY_IN_ISR(void * isr_context, alt_u32 id)
{
	image_yflip();
	*(key_in_base + 3) = 0;
	alt_putstr("KEY0\n");




}

int main()
{ 
  //*(key_in_base + 3) = 0;
  //alt_ic_isr_register(KEY_IN_IRQ_INTERRUPT_CONTROLLER_ID,KEY_IN_IRQ, KEY_IN_ISR,&context, 0x0);
  //*(key_in_base + 2) = 1;
  alt_putstr("Begin VGA\n");

  // Clear buffer
  clrBuffer();

  // Draw the Initial Image
  writeImage(0x2);

  while (1) {}
  return 0;
}
